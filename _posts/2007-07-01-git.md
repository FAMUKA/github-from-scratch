---
layout: post
title:  "Getting to know Git"
chapter: "two"
---

By now, you have used your GitHub repository to add and edit files, to publish a GitHub Page and to fork and edit repositories from your fellow learners. We told you a tiny bit about the "journal" part when using GitHub, but we skipped some very interesting stuff just to keep it simple for the moment. To put things in perspective we should make up for that now and tell you more about Git.

### Git and GitHub - partners, but not the same

In this course we started with GitHub. You know by now that GitHub is an online platform to host and share code. **GitHub uses Git** and adds community stuff around it. So GitHub needs Git, but Git doesn't need GitHub.

### What is Git?

Git is a *version control system* (VCS) - maybe you heard of others before, like SVN or CVS. A VCS keeps track of all changes made to a repository and adds information such as who changed it and when. Revisions can then be compared, restored, and with some types of files, merged.

What is special about Git, is that it doesn't need a remote server to host a repository. Git can be used locally, where it just keeps track of your own changes.
It also can be used as distributed VCS, so that code is hosted in different locations similar to a peer-to-peer system. Or you can choose to use it like other VCS as a server-client setup, in that case you just choose one of the hosts to act as a server. 

The latter is the case when you work with GitHub: You let GitHub host your project, while contributors work on it locally and *push* changes back to the central repo on GitHub. 

### Vocabulary & Workflow

Speaking of *pushing* changes, we probably should explain some vocabulary. Let's assume you already have a repository on GitHub as well as a local clone of that repository on your computer. (We will go through the setup step by step later.)

You start editing your files locally, let's just say you add a chapter to an OpenTechSchool course (which would be awesome). When you come to a point when you think the chapter is finished and ready to show to others, there are three steps to make:

- First, you *add* your changes to a stage, which makes a local snapshot. This separates changes from unchanged files and from changes you don't want to be committed yet.
- After that, you can *commit* your changes, which marks them as ready to be released. In this step you also add a *commit message*.
- To finally publish the changes you made to the repository on GitHub, you *push* the commit (or multiple commits). 

The separation of these three steps provides extra security and control so that you only push the things you really want to be in the remote repository. 

You may imagine this workflow as using a shopping cart:

- Put things in (stage) or take things out (unstage)
- Purchase at the register (commit)
- Go back, get and purchase some more items (stage, then commit)
- Take everything home (push)

When others work on the same repository from their local machines, it is possible that they changed a file while you are working on the same one. To avoid conflicts you would add a step to the beginning of this example workflow: You first *fetch* the changes from the remote repository (GitHub) so that your local copy is in sync with it. The remote and local changes would then be *merged* (often automatically) together. 

### Stash & Pop
Imagine you start working on writing that new chapter. In the middle of it, you get stuck and decide to stop for the moment to switch to another chapter and edit that instead. So you have an unfinished chapter you want to save somewhere - but it's not ready yet to be committed and pushed. 

Git provides a very helpful tool that lets you just *put things aside* for a while, so you have a clean working space without losing anything or being forced to push unfinished work:

- When you *stash* with Git, it puts the current changes to a safe place. 
- To get them back to resume working on them, you *pop*. 

Sounds funny, helps a lot.

### Branching

There's one more thing you should know about Git today. When building software (but also when writing course material) it is common to develop multiple versions of it simultaneously. For example when one version is already released and only bugs or typos are fixed, while another team starts adding new features which will be released later. These are two *branches* of the same project. 

You can *branch* from any point in your version history to create a separate development thread. For example you want to add a new part to your course material, comprising many new chapters and topics. You could start a *feature branch* for this, to keep the main development thread (*master*) untouched until the whole new part is finished. You then work on the branch, commiting and pushing as usual. The history and all changes will be tracked by Git, of course. Then, when everything is ready and everyone in your group agreed upon adding it to the next release, you would *merge* this branch back to the *master*.

### Hands on!

Ok, this was a very very theoretic chapter! Sorry for that. You are right, you should better *do* all this right now.
Go on, [use Git locally]({{ site.baseurl }}/local-development)!



